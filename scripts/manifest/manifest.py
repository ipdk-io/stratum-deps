#!/usr/bin/env python3
#
# Copyright 2023 Intel Corporation.
# SPDX-License-Identifier: Apache-2.0
#
# Generates files from manifest.json.
#

import argparse
import json
import logging
import os
from pprint import pprint
import sys

MANIFEST_FILE = "manifest.json"
CMAKE_FILE = "deps.cmake"
VERSION_FILE = "version.json"

CMAKE_HEADER = \
"""# URL and TAG definitions for dependencies
#
# Copyright 2022-2023 Intel Corporation
# SPDX-License-Identifier: Apache-2.0
#
# Generated by manifest.py
#
"""

logger = logging.getLogger('manifest')

def read_manifest(fname):
    """Read json file and return manifest"""
    path = os.path.join(os.path.dirname(__file__), fname)
    with open(path, 'r') as f:
        manifest = json.load(f)
    return manifest

#-----------------------------------------------------------------------
# write_cmake_file
#-----------------------------------------------------------------------
def write_cmake_file(manifest, out):
    write_cmake_header(out)
    for name in sorted(manifest.keys()):
        write_cmake_package(manifest[name], name.upper(), out)
    return

def write_cmake_header(out):
    out.write(CMAKE_HEADER)
    return

def write_cmake_package(pkg, name, out):
    out.write('\n')
    write_cmake_url(name, pkg, out)
    write_cmake_tag(name, pkg, out)
    write_cmake_version(name, pkg, out)
    return

def write_cmake_url(name, pkg, out):
    value = required(pkg, 'url')
    out.write('set({}_GIT_URL "{}")\n'.format(name, value))
    return

def write_cmake_tag(name, pkg, out):
    sha = optional(pkg, 'sha')
    tag = optional(pkg, 'tag')
    label = optional(pkg, 'label')

    if sha is not None:
        value = sha
        if label is not None:
            suffix = " # {}".format(label)
        elif tag is not None:
            suffix = " # {}".format(tag)
        else:
            suffix = ""
    elif tag is not None:
        value = tag
        suffix = ""
    else:
        log.error("No 'sha' or 'tag' defined for %s", pkg['name'])
        exit(1)

    out.write('set({}_GIT_TAG "{}"){}\n'.format(name, value, suffix))
    return

def write_cmake_version(name, pkg, out):
    version = optional(pkg, 'version')
    if version is not None:
        out.write('set({}_VERSION "{}")\n'.format(name, version))
    return

def required(pkg, item):
    if item not in pkg:
        log.error("'%s' not defined for %s", item, pkg['name'])
        exit(1)
    return pkg[item]

def optional(pkg, item):
    return pkg[item] if item in pkg else None

#-----------------------------------------------------------------------
# write_version_file
#-----------------------------------------------------------------------
def write_version_file(manifest, branch, out):
    out.write('{\n')
    out.write('    "%s": {\n' % branch)
    write_packages(manifest, out)
    out.write('    }\n')
    out.write('}\n')
    return

def write_packages(manifest, out):
    packages = sorted(version_packages(manifest))
    for index, key in enumerate(packages):
        pkg = manifest[key]
        comma = ',' if index < len(packages)-1 else ''
        out.write('        "%s": "%s"%s\n' % (pkg['name'], pkg['tag'], comma))
    return

def version_packages(manifest):
    """Returns a list of keys for packages to include in version.json"""
    return [x for x in manifest if 'tag' in manifest[x]]

#-----------------------------------------------------------------------
# main
#-----------------------------------------------------------------------
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)

    manifest = read_manifest(MANIFEST_FILE)

    with open(CMAKE_FILE, 'w') as outfile:
        write_cmake_file(manifest, outfile)

    with open(VERSION_FILE, 'w') as outfile:
        write_version_file(manifest, "main", outfile)

# __main__
